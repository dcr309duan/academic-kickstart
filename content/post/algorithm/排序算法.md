---
title: 排序算法
date: 2019-05-18T11:39:15.000Z
draft: false
math: true
tags: ["sort", "algorithm"]
categories: ["algorithm"]
image:
  caption: ''
  focal_point: ''
---

## $O(n^2)$ 的排序算法

### 为什么要学习 $O(n^2)$ 的排序算法

1. 这是一种简单的算法, 但是不因为其简单而不重要, 相反, 其是一种基础的算法, 是很多复杂问题的基础.
2. 编码简单, 易于实现, 是一些简单场景的首选.
3. 在一些特殊的情况下, 简单的排序算法会更加有效.
4. 简单的排序算法基础能够衍生出更复杂的排序算法.

### 选择排序

选择排序的算法非常简单:

- 假设我们有一个数组, 大小为 $n$.
- 需要进行 $n$ 次循环, 第 $i$ 次循环, 归位第 $i$ 个元素.
  - 找到 $[i, n)$ 中的最小值
  - 交换 i 和最小值位置的值.

![image-20190517174754990](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-17-094755.png)

```c++
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n; ++i) {
        // 第 i 个元素归位
        int minIndex = i;
        // 找到 [i, n) 元素中的最小值的位置
        for (int j = i; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 交换 i 和 minIndex 的值
        // swap 是 c++11 std 命名空间中的标准函数
        // 在之前的标准中, 需要 #include <algorithm>
        swap(arr[i], arr[minIndex]);
    }
}
```

### 插入排序

插入排序类似于我们打扑克的时候, 抓牌的过程, 每次抓一张牌, 插入到手中已有牌的正确位置.

![image-20190519112446179](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-19-032447.png)

- 假设我们有一个数组, 大小为 $n$.
- 需要进行 $n$ 次循环, 第 $i$ 次循环
  - 归为第 $i$ 个元素
  - 与前一个元素进行比较, 如果小于前一个元素, 交换位置.
  - 直到大于等于前一个元素, 结束第 $i$ 次循环

代码实现:

```c++
template<typename T>
void insertionSort(T arr[], int n) {
    for (int i = 1; i < n; ++i) {
        // 寻找元素 arr[i] 的合适插入位置
        for (int j = i; j > 0 && arr[j] < arr[j - 1]; --j) {
            swap(arr[j], arr[j - 1]);
        }
    }
}
```

我们和之前的选择排序进行比较, 结果如下:

```c++
int main() {
    int n = 10000;
    int *arr = SortTestHelper::generateRandomArray(n, 0, n);
    int *arr2 = SortTestHelper::copyArray(arr, n);

    SortTestHelper::testSort("Insertion Sort", insertionSort, arr, n);
    SortTestHelper::testSort("Selection Sort", selectionSort, arr, n);
    
    delete[] arr;
    delete[] arr2;
    return 0;
}
```

![image-20190519115113825](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-19-035114.png)

#### 插入排序的改进

相较于选择排序, 插入排序在循环过程中, 有提前结束的机制, 理论上效率应当比选择排序要高, 但是在上面的结果中, 为什么插入排序要比选择排序差呢? 主要原因在于交换, 我们上面的代码实现中, 每一次循环, 都要进行一次交换, 因此我们的一个优化思路是, 能不能减少交换的次数.

我们优化的思路是, 将交换操作使用数组的移动操作来代替, 能够大大减少数组中赋值操作的消耗 (一次交换是三次赋值), 具体来说, 就是待排序的元素与前一个元素比较, 如果小于前一个元素, 则将该元素复制一份, 将前一个元素后移一位; 然后再将待排序元素与前一个元素进行比较, 直到不小于前一个元素为止.

对于几乎为顺序的数组来说, 插入排序的效率会非常高, 使用如下代码进行测试:

```c++
int main() {
    int n = 10000;
    int *arr = SortTestHelper::generateNearlyOrderedArray(n, 100);
    int *arr2 = SortTestHelper::copyArray(arr, n);

    SortTestHelper::testSort("Insertion Sort", insertionSort, arr, n);
    SortTestHelper::testSort("Selection Sort", selectionSort, arr2, n);

    delete[] arr;
    delete[] arr2;
    return 0;
}
```

测试结果如下:

![image-20190520151445412](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-20-071445.png)

插入排序在极端情况下, 即对于完全有序的数组, 其是一个时间复杂度为 $O(n)$ 的算法. 因此插入排序算法也不是一无是处.

### 冒泡排序 (Bubble Sort)

### 希尔排序 (Shell Sort)

## 测试辅助函数

### 生成随机数组

```c++
#include <iostream>
#include <ctime>
#include <cassert>

using namespace std;

namespace SortTestHelper {
    // 生成有 n 个元素的随机数组, 每个元素的随机范围为 [rangeL, rangeR]
    int *generateRandomArray(int n, int rangeL, int rangeR) {
        assert(rangeL <= rangeR);
        int *arr = new int[n];
        srand(time(nullptr));
        for (int i = 0; i < n; i++) {
            // rand() 返回 0 到 RAND_MAX 之间的伪随机值
            // RAND_MAX 至少为 32767
            arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;
        }
        return arr;
    }

    template<typename T>
    void printArray(T arr[], int n) {
        for (int i = 0; i < n; ++i) {
            cout << arr[i] << " ";
        }
        cout << endl;
        return;
    }
}
```

上面是两个辅助测试函数, 一个是随机生成测试数组, 一个是打印输出, 都非常简单.

### 生成近乎有序的数组

```
int *generateNearlyOrderedArray(int n, int swapTimes) {
    int *arr = new int[n];
    for (int i = 0; i < n; ++i) {
        arr[i] = i;
    }
    srand(time(nullptr));
    for (int j = 0; j < swapTimes; ++j) {
        int posx = rand() % n;
        int posy = rand() % n;
        swap(arr[posx], arr[posy]);
    }
    return arr;
}
```

上面代码生成一个近乎有序的数组, 通过对一个有序数组进行交换的方式生成, 其中 `swapTimes` 决定了交换的次数.

### 验证排序有效性

验证排序有效性只需要比较

```c++
template<typename T>
bool isSorted(T arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        if (arr[i] > arr[i + 1]) {
            return false;
        }
    }
    return true;
}
```

### 测试算法性能 (运行时长)

```c++
template<typename T>
void testSort(const string &sortName, void(*sort)(T[], int), T arr[], int n) {
    // 记录开始时间
    clock_t startTime = clock();
    sort(arr, n);
    // 记录结束时间
    clock_t endTime = clock();
    assert(isSorted(arr, n));
    // 输出测试信息
    cout << sortName << " : " << double(endTime - startTime) / CLOCKS_PER_SEC << "s" << endl;
}
```

### 复制数组

```c++
int *copyArray(int a[], int n) {
    int *arr = new int[n];
    copy(a, a + n, arr);
    return arr;
}
```