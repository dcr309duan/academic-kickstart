---
title: 排序算法
date: 2019-05-18T11:39:15.000Z
draft: false
math: true
tags: ["sort", "algorithm"]
categories: ["algorithm"]
image:
  caption: ''
  focal_point: ''
---

## $O(n^2)$ 的排序算法

### 为什么要学习 $O(n^2)$ 的排序算法

1. 这是一种简单的算法, 但是不因为其简单而不重要, 相反, 其是一种基础的算法, 是很多复杂问题的基础.
2. 编码简单, 易于实现, 是一些简单场景的首选.
3. 在一些特殊的情况下, 简单的排序算法会更加有效.
4. 简单的排序算法基础能够衍生出更复杂的排序算法.

### 选择排序

选择排序的算法非常简单:

- 假设我们有一个数组, 大小为 $n$.
- 需要进行 $n$ 次循环, 第 $i$ 次循环, 归位第 $i$ 个元素.
  - 找到 $[i, n)$ 中的最小值
  - 交换 i 和最小值位置的值.

![image-20190517174754990](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-17-094755.png)

```c++
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n; ++i) {
        // 第 i 个元素归位
        int minIndex = i;
        // 找到 [i, n) 元素中的最小值的位置
        for (int j = i; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 交换 i 和 minIndex 的值
        // swap 是 c++11 std 命名空间中的标准函数
        // 在之前的标准中, 需要 #include <algorithm>
        swap(arr[i], arr[minIndex]);
    }
}
```

### 插入排序

插入排序类似于我们打扑克的时候, 抓牌的过程, 每次抓一张牌, 插入到手中已有牌的正确位置.

![image-20190519112446179](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-19-032447.png)

- 假设我们有一个数组, 大小为 $n$.
- 需要进行 $n$ 次循环, 第 $i$ 次循环
  - 归为第 $i$ 个元素
  - 与前一个元素进行比较, 如果小于前一个元素, 交换位置.
  - 直到大于等于前一个元素, 结束第 $i$ 次循环

代码实现:

```c++
template<typename T>
void insertionSort(T arr[], int n) {
    for (int i = 1; i < n; ++i) {
        // 寻找元素 arr[i] 的合适插入位置
        for (int j = i; j > 0 && arr[j] < arr[j - 1]; --j) {
            swap(arr[j], arr[j - 1]);
        }
    }
}
```

我们和之前的选择排序进行比较, 结果如下:

```c++
int main() {
    int n = 10000;
    int *arr = SortTestHelper::generateRandomArray(n, 0, n);
    int *arr2 = SortTestHelper::copyArray(arr, n);

    SortTestHelper::testSort("Insertion Sort", insertionSort, arr, n);
    SortTestHelper::testSort("Selection Sort", selectionSort, arr, n);
    
    delete[] arr;
    delete[] arr2;
    return 0;
}
```

![image-20190519115113825](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-19-035114.png)

#### 插入排序的改进

相较于选择排序, 插入排序在循环过程中, 有提前结束的机制, 理论上效率应当比选择排序要高, 但是在上面的结果中, 为什么插入排序要比选择排序差呢? 主要原因在于交换, 我们上面的代码实现中, 每一次循环, 都要进行一次交换, 因此我们的一个优化思路是, 能不能减少交换的次数.

我们优化的思路是, 将交换操作使用数组的移动操作来代替, 能够大大减少数组中赋值操作的消耗 (一次交换是三次赋值), 具体来说, 就是待排序的元素与前一个元素比较, 如果小于前一个元素, 则将该元素复制一份, 将前一个元素后移一位; 然后再将待排序元素与前一个元素进行比较, 直到不小于前一个元素为止.

对于几乎为顺序的数组来说, 插入排序的效率会非常高, 使用如下代码进行测试:

```c++
int main() {
    int n = 10000;
    int *arr = SortTestHelper::generateNearlyOrderedArray(n, 100);
    int *arr2 = SortTestHelper::copyArray(arr, n);

    SortTestHelper::testSort("Insertion Sort", insertionSort, arr, n);
    SortTestHelper::testSort("Selection Sort", selectionSort, arr2, n);

    delete[] arr;
    delete[] arr2;
    return 0;
}
```

插入排序在极端情况下, 即对于完全有序的数组, 其是一个时间复杂度为 $O(n)$ 的算法. 因此插入排序算法也不是一无是处.

### 冒泡排序 (Bubble Sort)

冒泡排序过程中, 每一次循环中, 如果相邻的两个元素之间顺序错误, 则交换这两个元素, 我们可以想象, 最大的那个元素会像冒泡一样一直到最后一个位置, 这就是冒泡排序名字的由来, 那么下一次循环就可以少进行一次比较, 因为最后一个元素已经归位. 那么基于此我们有如下实现:

```c++
template<typename T>
void bubbleSort(T *arr, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```

#### 冒泡排序的优化

对于上述代码, 我们循环次数是固定的, 然而, 冒泡排序可以使用提前结束的条件判定, 如果在一次循环过程中, 没有发生交换, 那么就可以结束算法.

```c++
template<typename T>
void bubbleSort2(T *arr, int n) {
    bool isSwaped;
    do {
        isSwaped = false;
        for (int j = 0; j < n - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                isSwaped = true;
            }
        }
        n--;
    } while (isSwaped);
}
```

#### 进一步优化

其实, 我们还可以对冒泡排序进行进一步优化, 之前的算法中, 我们每一轮迭代只归位最后一个元素, 其实, 在最后一个发生交换的元素之后的元素, 都可以认为已经完成了归位, 因此, 我们的算法还可以进一步优化.

```c++
template<typename T>
void bubbleSort3(T *arr, int n) {
    int swapPosition;
    do {
        // 为零表示没有进行交换
        swapPosition = 0;
        for (int j = 0; j < n - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapPosition = j + 1;
            }
        }
        n = swapPosition;
    } while (swapPosition > 0);
}
```

### 希尔排序 (Shell Sort)

希尔排序利用的是插入排序对近似有序数组的排序效率非常高, 希尔排序采用的是分而治之, 逐渐合并的思想.

第一步, 分. 将原数组以相等的间隔进行划分.

第二步, 对每一个分数组进行插入排序.

第三步, 逐渐缩小划分的间隔, 直到间隔为 1, 那么即完成了整个数组的排序.

通过对每一个子序列先进性排序, 使得数组整体上呈现近似顺序的状态, 因此使用插入排序会非常高效.

为了高效, 具体操作过程中, 第一轮排序, 每一个子数组中包含 3 个元素, 然后以三倍的形式扩大, 为了使最终间距能够到达 1, 我们可以从 1 开始生成一个 increment sequence, 然后对每个子序列进行插入排序.

```c++
template <typename T>
void shellSort(T arr[], int n) {
	// 生成 increment sequence
  int h = 1;
  while (h < n) {
  	h = h * 3 + 1;
  }
  
  // 等于 1 的时候进行最后一轮排序
  while (h >= 1) {
  	
    // 对每个子序列进行排序
    // 例如: 对于 1 2 3 4 5 6 7 8 9 10
    // 首先, 子序列分别为:
   	// 1, 5
    // 2, 6
    // 3, 7
    // 4, 8
    // 1, 5, 9
    // 2, 6, 10
    int j;
    T e = arr[j];
    for (j = i; j > 0 && arr[j - h] > e; j -= h) {
    	arr[j] = arr[j - h];
    }
    arr[j] = e;
    h /= 3;
  }
}
```

## $O(nlogn)$ 的排序算法

### 归并排序 (Merge Sort)

归并排序算法思路: 将待排序数组分成两部分, 对每一部分进行排序, 然后再将两部分合并. 其中, 对于每一部分的排序, 又可以继续利用归并排序来完成.

![image-20190527170913971](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-27-090914.png)

#### 归并排序的分析

我们可以看出, 在有三个元素的时候, 我们分成了三个层级后, 每一个子序列中就只有一个元素了 (8 个元素, 每次二分, $log_2(8) = 3$ 次后就完成划分).

#### 归并的过程

![image-20190527171729722](https://markdown-1252040768.cos.ap-beijing.myqcloud.com/2019-05-27-091730.png)

归并的过程需要额外开辟一个同等大小的空间, 使用三个指针来完成归并.

下方表示待归并的数组, 上方用于存储最终归并的结果. 蓝色指针指向下一个待归位的位置, 两个橙色指针分别指向两个待归并数组中下一个带归位的元素, 每一次比较两个橙色指针所指向的元素大小, 选择较小的那个元素填入蓝色指针位置, 并将蓝色指针后移一位, 同时将该橙色指针也后移一位, 知道完成归并.

这一步归并的时间复杂度为 $O(n)$ 级别, 需要完成归并的次数为 $O(logn)$, 算法总体的时间复杂度为 $O(nlogn)$.

#### 归并排序的递归实现

```c++
// arr 的 [l, mid] 和 [mid + 1, r] 合并
template<typename T>
void __merge(T arr[], int l, int mid, int r) {
    T aux[r - l + 1];
    for (int i = l; i <= r; ++i) {
        aux[i - l] = arr[i];
    }
    int i = l;
    int j = mid + 1;
    for (int k = l; k <= r; k++) {
        if (i > mid) {
            arr[k] = aux[j - l];
            j++;
        } else if (j > r) {
            arr[k] = aux[i - l];
            i++;
        } else if (aux[i - l] < aux[j - l]) {
            arr[k] = aux[i - l];
            i++;
        } else {
            arr[k] = aux[j - l];
            j++;
        }
    }
}

// 递归使用归并排序, 对 arr[l, ..., r] 的范围进行排序
template<typename T>
void __mergeSort(T arr[], int l, int r) {
    if (l >= r) {
        return;
    } else {
        int mid = (l + r) / 2;
        __mergeSort(arr, l, mid);
        __mergeSort(arr, mid + 1, r);
        __merge(arr, l, mid, r);
    }
}

template<typename T>
void mergeSort(T arr[], int n) {
    __mergeSort(arr, 0, n - 1);
}
```

#### 改进1

增加了判断, 只在 `arr[mid] > arr[mid + 1]` 的情况下才进行 `merge`.

```c++
// 递归使用归并排序, 对 arr[l, ..., r] 的范围进行排序
template<typename T>
void __mergeSort(T arr[], int l, int r) {
    if (l >= r) {
        return;
    } else {
        int mid = (l + r) / 2;
        __mergeSort(arr, l, mid);
        __mergeSort(arr, mid + 1, r);
        if (arr[mid] > arr[mid + 1]) {
            __merge(arr, l, mid, r);
        }
    }
}
```

#### 改进2

并不需要递归到底, 在只有 16 个元素的时候, 使用插入排序进行排序.

```c++
// 递归使用归并排序, 对 arr[l, ..., r] 的范围进行排序
template<typename T>
void __mergeSort(T arr[], int l, int r) {
//    if (l >= r) {
//        return;
//    }
    if (r - l <= 15) {
        insertionSort(arr, l, r);
        return;
    } else {
        int mid = (l + r) / 2;
        __mergeSort(arr, l, mid);
        __mergeSort(arr, mid + 1, r);
        if (arr[mid] > arr[mid + 1]) {
            __merge(arr, l, mid, r);
        }
    }
}
```

## 测试辅助函数

### 生成随机数组

```c++
#include <iostream>
#include <ctime>
#include <cassert>

using namespace std;

namespace SortTestHelper {
    // 生成有 n 个元素的随机数组, 每个元素的随机范围为 [rangeL, rangeR]
    int *generateRandomArray(int n, int rangeL, int rangeR) {
        assert(rangeL <= rangeR);
        int *arr = new int[n];
        srand(time(nullptr));
        for (int i = 0; i < n; i++) {
            // rand() 返回 0 到 RAND_MAX 之间的伪随机值
            // RAND_MAX 至少为 32767
            arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;
        }
        return arr;
    }

    template<typename T>
    void printArray(T arr[], int n) {
        for (int i = 0; i < n; ++i) {
            cout << arr[i] << " ";
        }
        cout << endl;
        return;
    }
}
```

上面是两个辅助测试函数, 一个是随机生成测试数组, 一个是打印输出, 都非常简单.

### 生成近乎有序的数组

```
int *generateNearlyOrderedArray(int n, int swapTimes) {
    int *arr = new int[n];
    for (int i = 0; i < n; ++i) {
        arr[i] = i;
    }
    srand(time(nullptr));
    for (int j = 0; j < swapTimes; ++j) {
        int posx = rand() % n;
        int posy = rand() % n;
        swap(arr[posx], arr[posy]);
    }
    return arr;
}
```

上面代码生成一个近乎有序的数组, 通过对一个有序数组进行交换的方式生成, 其中 `swapTimes` 决定了交换的次数.

### 验证排序有效性

验证排序有效性只需要比较

```c++
template<typename T>
bool isSorted(T arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        if (arr[i] > arr[i + 1]) {
            return false;
        }
    }
    return true;
}
```

### 测试算法性能 (运行时长)

```c++
template<typename T>
void testSort(const string &sortName, void(*sort)(T[], int), T arr[], int n) {
    // 记录开始时间
    clock_t startTime = clock();
    sort(arr, n);
    // 记录结束时间
    clock_t endTime = clock();
    assert(isSorted(arr, n));
    // 输出测试信息
    cout << sortName << " : " << double(endTime - startTime) / CLOCKS_PER_SEC << "s" << endl;
}
```

### 复制数组

```c++
int *copyArray(int a[], int n) {
    int *arr = new int[n];
    copy(a, a + n, arr);
    return arr;
}
```

